<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>Flying Cow â€“ Pro Physics</title>
<script src="https://telegram.org/js/telegram-web-app.js"></script>
<style>
  body { margin:0; background:#0f172a; overflow:hidden; }
  canvas { display:block; margin:auto; background:#1e293b; }
</style>
</head>
<body>

<canvas id="game" width="360" height="640"></canvas>

<script>
Telegram.WebApp.ready();

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

// ===== PRO PHYSICS CONSTANTS =====
const FIXED_DT = 1/120;        // fixed timestep (120 Hz)
const GRAVITY = 2200;          // px/s^2
const JUMP_IMPULSE = -520;     // px/s
const MAX_FALL_SPEED = 900;    // terminal velocity
const DAMPING = 0.995;         // micro damping (feel)
const PIPE_SPEED = 160;        // px/s
const PIPE_GAP = 150;

// Input buffer (forgiving)
const INPUT_BUFFER = 0.12;     // seconds

// ===== GAME STATE =====
let state = "start"; // start | play | over
let score = 0;

let cow = {
  x: 80,
  y: 300,
  w: 40,
  h: 30,
  vy: 0
};

let pipes = [];
let lastTime = 0;
let accumulator = 0;
let inputTimer = 0;

// ===== HELPERS =====
function randY() {
  return Math.random() * 260 + 60;
}

function resetGame() {
  score = 0;
  cow.y = 300;
  cow.vy = 0;
  pipes = [{ x: 360, y: randY(), passed:false }];
  state = "start";
  inputTimer = 0;
}

function jump() {
  cow.vy = JUMP_IMPULSE;
}

// ===== UPDATE (FIXED) =====
function fixedUpdate(dt) {
  if (state !== "play") return;

  // gravity
  cow.vy += GRAVITY * dt;
  if (cow.vy > MAX_FALL_SPEED) cow.vy = MAX_FALL_SPEED;
  cow.vy *= DAMPING;
  cow.y += cow.vy * dt;

  // bounds
  if (cow.y < 0 || cow.y + cow.h > 640) {
    state = "over";
    return;
  }

  // pipes
  pipes.forEach(p => {
    p.x -= PIPE_SPEED * dt;

    // forgiving hitbox (slightly smaller cow)
    const hx = cow.x + 4;
    const hy = cow.y + 4;
    const hw = cow.w - 8;
    const hh = cow.h - 8;

    const hit =
      hx < p.x + 50 &&
      hx + hw > p.x &&
      (hy < p.y || hy + hh > p.y + PIPE_GAP);

    if (hit) state = "over";

    if (!p.passed && p.x + 50 < cow.x) {
      p.passed = true;
      score++;
    }
  });

  // spawn
  if (pipes[pipes.length - 1].x < 180) {
    pipes.push({ x: 360, y: randY(), passed:false });
  }
  if (pipes[0].x < -60) pipes.shift();
}

// ===== DRAW =====
function draw() {
  ctx.clearRect(0,0,360,640);

  // Cow body
ctx.fillStyle = "white";
ctx.fillRect(cow.x, cow.y, cow.w, cow.h);

// Eyes
ctx.fillStyle = "black";
ctx.fillRect(cow.x + 10, cow.y + 10, 4, 4);
ctx.fillRect(cow.x + 24, cow.y + 10, 4, 4);

// Mouth (serious ðŸ˜)
ctx.fillRect(cow.x + 16, cow.y + 22, 8, 2);

// Blonde hair
ctx.fillStyle = "#F6D365";
ctx.beginPath();
ctx.moveTo(cow.x + 6, cow.y);
ctx.lineTo(cow.x + 30, cow.y);
ctx.lineTo(cow.x + 22, cow.y - 8);
ctx.closePath();
ctx.fill();

  // Pipes
  ctx.fillStyle = "#22c55e";
  pipes.forEach(p => {
    ctx.fillRect(p.x, 0, 50, p.y);
    ctx.fillRect(p.x, p.y + PIPE_GAP, 50, 640);
  });

  // UI
  ctx.fillStyle = "white";
  ctx.font = "20px Arial";
  ctx.fillText("Score: " + score, 10, 28);

  ctx.textAlign = "center";
  ctx.font = "24px Arial";

  if (state === "start") {
    ctx.fillText("ðŸ® Flying Cow", 180, 280);
    ctx.font = "18px Arial";
    ctx.fillText("Tap to Start", 180, 320);
  }
  if (state === "over") {
    ctx.fillText("Game Over", 180, 300);
    ctx.font = "18px Arial";
    ctx.fillText("Tap to restart", 180, 340);
  }
  ctx.textAlign = "left";
}

// ===== MAIN LOOP (FIXED TIMESTEP) =====
function loop(time) {
  if (!lastTime) lastTime = time;
  let delta = (time - lastTime) / 1000;
  if (delta > 0.25) delta = 0.25;
  lastTime = time;

  accumulator += delta;
  inputTimer -= delta;

  while (accumulator >= FIXED_DT) {
    // buffered input
    if (inputTimer > 0 && state === "play") {
      jump();
      inputTimer = 0;
    }
    fixedUpdate(FIXED_DT);
    accumulator -= FIXED_DT;
  }

  draw();
  requestAnimationFrame(loop);
}

// ===== INPUT =====
canvas.addEventListener("touchstart", () => {
  if (state === "start") {
    state = "play";
    jump();
  } else if (state === "play") {
    inputTimer = INPUT_BUFFER; // buffer
  } else if (state === "over") {
    resetGame();
  }
});

resetGame();
requestAnimationFrame(loop);
</script>

</body>
</html>
